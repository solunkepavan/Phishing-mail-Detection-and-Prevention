# -*- coding: utf-8 -*-
"""phishing-email-detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ayvXELAPFTxV_GkQ2xRxVGA0kwZjw9gU
"""

!pip install gdown

!gdown --id 1cOohptk4-83tBadQvdkjGE8AZ9Tp3yuW -O documents.zip
!unzip -q documents.zip -d documents

"""### Importing libraries

"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

"""### Data importing and Preprocessing"""

#Import the Dataset
df= pd.read_csv("/content/documents/Phishing_Email.csv")
df.head()

df.head(10)

# Check NAN values
df.isna().sum()

#Drop tha Na values
df = df.dropna()
print(df.isna().sum())

#dataset shape
df.shape

# Count the occurrences of each E-mail type.
email_type_counts = df['Email Type'].value_counts()
print(email_type_counts)

# Assuming you have already calculated email_type_counts as you mentioned
email_type_counts = df['Email Type'].value_counts()
colors = ['#66b3ff','#ff9999']
# Create a pie chart
plt.figure(figsize=(6, 6))  # Set the figure size
plt.pie(email_type_counts, labels=email_type_counts.index, colors=colors, autopct='%1.1f%%', startangle=140)
plt.title("Email Type Distribution")

# Display the pie chart
plt.show()

"""### Our Dataset is ready"""

# split the data into a metrix of features X and Dependent Variable y
X = df["Email Text"].values
y = df["Email Type"].values

# lets splitting Our Data
from sklearn.model_selection import train_test_split
X_train,x_test,y_train,y_test = train_test_split(X, y, test_size = 0.3, random_state = 0)

"""### Build RandomForestClassifier Model

"""

# Importing Libraries for the model ,Tfidf and Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.pipeline import Pipeline

# define the Classifier
classifier = Pipeline([("tfidf",TfidfVectorizer() ),("classifier",RandomForestClassifier(n_estimators=100))])# add another hyperparamters as U want

# Trian Our model
classifier.fit(X_train,y_train)

# Prediction
y_pred = classifier.predict(x_test)

"""### Check the Accuracy"""

# Importing classification_report,accuracy_score,confusion_matrix
from sklearn.metrics import classification_report,accuracy_score,confusion_matrix

#accuracy_score
accuracy_score(y_test,y_pred)

#confusion_matrix
confusion_matrix(y_test,y_pred)

#classification_report
classification_report(y_test,y_pred)

from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import MultinomialNB
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier

# Define different classifiers
classifiers = [
    ("Random Forest", RandomForestClassifier(n_estimators=100)),
    ("Gradient Boosting", GradientBoostingClassifier()),
    ("Multinomial Naive Bayes", MultinomialNB()),
    ("Support Vector Machine", SVC(kernel='linear'))
]

# Loop through different classifiers and fit the model
for classifier_name, classifier in classifiers:
    model = Pipeline([
        ("tfidf", TfidfVectorizer()),
        ("classifier", classifier)
    ])

    model.fit(X_train, y_train)

    # Prediction
    y_pred = model.predict(x_test)

    # Evaluate or print classifier results
    # Example: Print classifier name and accuracy
    accuracy = model.score(x_test, y_test)
    print(f"{classifier_name} Accuracy: {accuracy:.2f}")

# Plotting the comparison graph
plt.figure(figsize=(10, 6))
plt.bar([name for name, _ in classifiers], accuracy, color=['blue', 'green', 'orange', 'red'])
plt.xlabel('Classifiers')
plt.ylabel('Accuracy')
plt.title('Accuracy Comparison of Different Classifiers')
plt.xticks(rotation=45)
plt.ylim(0, 1)  # Set y-axis limits
plt.show()

"""### Build MultinomialNB Model"""

from sklearn.naive_bayes import MultinomialNB
# define the Classifier
SVC_classifier = Pipeline([("tfidf",TfidfVectorizer() ),("Support Vector Machine", SVC(kernel='linear'))])# add another hyperparamters as U want

# traing the SVM model
SVC_classifier.fit(X_train,y_train)

# y_pred. for SVM model
SVC_y_pred = SVC_classifier.predict(x_test)

# check the SVM model accuracy
accuracy_score(y_test,SVC_y_pred )

#confusion_matrix
confusion_matrix(y_test,SVC_y_pred)

print(df["Email Text"][4])
print("======================================================================================================================================")
print(df["Email Type"][4])

# Take email text input from the user
user_input = input("Enter the email text: ")
# Use the MVB_classifier to make predictions
predicted_label = SVC_classifier.predict([user_input])
print("==================================================================================================================")
# Output the predicted label
print("Predicted Email Type:", predicted_label[0])

